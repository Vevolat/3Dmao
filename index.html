<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 模型全屏展示</title>
    <!-- 使用备用 CDN 方式导入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #f0f0f0;
            overflow: hidden;
        }
        #model-container {
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
        }
        
        /* 加载动画样式 */
        #loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s ease-out, visibility 0.8s;
        }
        
        #loading-container.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #ccc;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-align: center;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* FPS显示样式 */
        #fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-radius: 4px;
            z-index: 999;
        }
        
        /* 缩放控制按钮样式 - 毛玻璃效果 */
        .zoom-controls {
            position: fixed;
            right: 20px;
            bottom: 60px; /* 向上移动了一些距离 */
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 999;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.8); /* 黑色背景 */
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background-color: rgba(0, 0, 0, 1);
            transform: scale(1.1);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* 加载提示样式 */
        .loading-tip {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .loading-tip.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .zoom-btn:hover {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* 进度条样式 */
        .progress-container {
            width: 80%;
            max-width: 600px;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        /* 加载详情信息 */
        .loading-details {
            color: #555;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            max-width: 80%;
        }
        
        /* 加载日志区域 */
        .loading-logs {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            z-index: 997;
            display: none;
        }
        
        /* 显示日志按钮 */
        #show-logs-btn {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 998;
        }
        
        #show-logs-btn:hover {
            background-color: rgba(76, 175, 80, 1);
        }
    </style>
</head>
<body>
    <div id="model-container">
    </div>
    
    <!-- 加载动画容器 -->
    <div id="loading-container">
        <div class="loading-spinner"></div>
        <div class="loading-text">正在准备加载...</div>
        <div class="progress-container">
            <div class="progress-bar"></div>
        </div>
        <div class="loading-details">初始化资源...</div>
    </div>
    
    <!-- 加载日志按钮 -->
    <button id="show-logs-btn">显示加载日志</button>
    <div id="loading-logs" class="loading-logs"></div>
    
    <!-- FPS显示容器 -->
    <!-- FPS显示 -->
    <div id="fps-counter">FPS: 0</div>
    
    <!-- 加载提示 -->
    <div id="loading-tip" class="loading-tip">
    提示：使用鼠标左键控制视角X轴移动，右下角按钮放大缩小模型
    </div>
    
    <!-- 缩放控制按钮 -->
    <div class="zoom-controls">
        <button id="zoom-in-btn" class="zoom-btn">+</button>
        <button id="zoom-out-btn" class="zoom-btn">-</button>
    </div>
    <script type="module">
        // 使用标准 ES Module 导入 Three.js 和相关组件
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        
        // 初始化变量
        let scene, camera, renderer, controls;
        let loadedModels = [];
        let modelFiles = [];
        let fpsCounter = null;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let chunkLoader = null;
        let modelChunks = {}; // 存储模型块
        let loadingManager = null;
        let loadedChunksCount = 0; // 已加载的块数量
        let totalChunksCount = 0; // 总块数量
        let isLoadingChunks = false; // 是否正在加载块
        let chunkLoadingQueue = []; // 块加载队列
        let maxConcurrentChunkLoads = 2; // 最大并发加载数
        let failedChunks = []; // 存储加载失败的块
        let maxRetries = 3; // 每个块的最大重试次数
        
        // 资源加载跟踪变量
        let totalBytesLoaded = 0; // 已加载总字节数
        let totalBytesToLoad = 0; // 预计总字节数
        let startTime = 0; // 开始加载时间
        let averageLoadSpeed = 0; // 平均加载速度 (KB/s)
        let lastLoadedTime = 0; // 最后加载时间点
        let lastLoadedBytes = 0; // 最后加载字节数
        let isLoadingComplete = false; // 加载是否完成
        
        // 缓存机制
        const resourceCache = new Map(); // 资源缓存
        const CACHE_ENABLED = true; // 是否启用缓存
        const CACHE_EXPIRE_TIME = 60 * 60 * 1000; // 缓存过期时间 (1小时)
        
        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // 设置为灰色背景
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                powerPreference: 'high-performance'
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('model-container').appendChild(renderer.domElement);
            
            // 获取FPS计数器元素
            fpsCounter = document.getElementById('fps-counter');
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // 添加顶部灯光
            const topLight = new THREE.DirectionalLight(0xffffff, 0.8);
            topLight.position.set(0, 10, 0); // 放置在顶部位置
            scene.add(topLight);
            
            // 添加轨道控制器 - 按照用户要求配置交互控制
            controls = new OrbitControls(camera, renderer.domElement);
            
            // 基础配置
            controls.enableDamping = true; // 启用阻尼效果，使操作更平滑
            controls.dampingFactor = 0.05; // 设置阻尼系数
            
            // 配置鼠标按钮 - 按照用户要求配置交互控制
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,     // 左键用于平移（控制x轴移动）
                MIDDLE: THREE.MOUSE.ROTATE, // 鼠标中键用于旋转（同时控制Yaw和Pitch）
                RIGHT: THREE.MOUSE.NONE     // 禁用右键功能
            };
            
            // 配置触摸控制
            controls.touches = {
                ONE: THREE.TOUCH.NONE,      // 禁用单指操作
                TWO: THREE.TOUCH.NONE       // 禁用双指操作
            };
            
            // 缩放视图配置 - 滚轮控制放大缩小
            controls.enableZoom = true;     // 启用缩放
            controls.zoomSpeed = 1.0;       // 设置缩放速度
            controls.enableMouseZoom = true; // 启用鼠标滚轮缩放
            
            // 旋转视图配置 - 按下滚轮控制Yaw和Pitch
            controls.enableRotate = true;   // 启用旋转
            controls.rotateSpeed = 1.5;     // 设置旋转速度
            
            // 禁用平移功能
            controls.enablePan = true;     // 启用平移功能（因为我们将左键设置为平移控制）
            controls.panSpeed = 1.0;       // 设置平移速度
            
            // 禁用键盘控制
            controls.enableKeys = false;    // 禁用键盘控制
            
            // 移除所有旋转限制，确保Yaw和Pitch可以自由旋转
            controls.minPolarAngle = 0;     // 允许向下旋转到水平
            controls.maxPolarAngle = Math.PI; // 允许向上旋转到完全倒置
            controls.minAzimuthAngle = -Infinity; // 允许无限向左旋转
            controls.maxAzimuthAngle = Infinity;  // 允许无限向右旋转
            
            // 缩放距离限制
            controls.minDistance = 0.1;     // 最小缩放距离
            controls.maxDistance = 1000;    // 最大缩放距离
            
            // 设置窗口大小变化监听
            window.addEventListener('resize', onWindowResize);
            
            // 初始化加载管理器
            loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
                const percent = Math.round((itemsLoaded / itemsTotal) * 100);
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = `正在加载模型块: ${percent}%`;
                }
            };
            
            // 开始渲染循环
            animate();
        }
        
        // 窗口大小变化时更新相机和渲染器
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 渲染循环 - 添加帧率优化
        let lastFrameTime = 0;
        const MAX_FPS = 60;
        const MIN_FRAME_TIME = 1000 / MAX_FPS;
        
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            // 限制帧率以提高性能
            if (timestamp - lastFrameTime < MIN_FRAME_TIME) {
                return;
            }
            
            lastFrameTime = timestamp;
            
            // 更新控制器
            controls.update();
            
            // 计算和更新FPS
            if (fpsCounter) {
                frameCount++;
                if (timestamp - lastFpsUpdate >= 1000) { // 每秒更新一次
                    const fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
                    fpsCounter.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastFpsUpdate = timestamp;
                }
            }
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 初始化分块加载器
        function initChunkLoader() {
            // 创建GLTFLoader
            const loader = new GLTFLoader(loadingManager);
            
            // 创建和配置DracoLoader用于压缩模型
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);
            
            // 配置meshopt解码器
            loader.setMeshoptDecoder(MeshoptDecoder);
            
            return loader;
        }
        
        // 分块加载模型
        function loadModelInChunks(modelName) {
            chunkLoader = initChunkLoader();
            
            // 获取加载容器引用
            const loadingContainer = document.getElementById('loading-container');
            const loadingText = document.querySelector('.loading-text');
            
            function hideLoadingAnimation() {
                if (loadingContainer) {
                    console.log('隐藏加载动画');
                    loadingContainer.classList.add('hidden');
                }
            }
            
            function showError(message) {
                if (loadingText) {
                    loadingText.textContent = message;
                    loadingText.style.color = '#ff0000'; // 红色错误信息
                }
                console.error('模型加载错误:', message);
                
                // 5秒后隐藏加载动画并显示替代几何体
                setTimeout(() => {
                    hideLoadingAnimation();
                    createFallbackGeometry();
                }, 3000);
            }
            
            // 检查文件大小（通过HEAD请求）
            function checkFileSize(path) {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('HEAD', path, true);
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200) {
                                const fileSize = parseInt(xhr.getResponseHeader('Content-Length')) || 0;
                                resolve(fileSize);
                            } else {
                                reject(new Error(`无法获取文件大小，状态码: ${xhr.status}`));
                            }
                        }
                    };
                    xhr.onerror = function() {
                        reject(new Error('网络错误，无法获取文件大小'));
                    };
                    xhr.send();
                });
            }
            
            // 增强的路径处理逻辑 - 适应不同环境
            const possiblePaths = [
                modelName,                           // 直接文件名
                '/' + modelName,                      // 根目录
                './' + modelName,                     // 当前目录
                './模型/' + modelName,                 // 模型子目录
                '模型/' + modelName                    // 另一种模型目录格式
            ];
            
            async function startLoading() {
                try {
                    // 尝试第一个路径（主要路径）
                    const mainPath = possiblePaths[0];
                    
                    // 先检查文件大小
                    const fileSize = await checkFileSize(mainPath);
                    const sizeInGB = (fileSize / (1024 * 1024 * 1024)).toFixed(2);
                    
                    // 更新加载文本
                    if (loadingText) {
                        loadingText.textContent = `准备加载大型模型(${sizeInGB}GB)...`;
                    }
                    
                    // 配置分块加载选项
                    const chunkOptions = {
                        // 使用流式加载
                        streaming: true,
                        // 优先级设置（基于相机距离）
                        prioritizeLoadedChunks: true,
                        // 设置最大加载块数
                        maxConcurrentChunks: 3,
                        // 内存优化
                        useBrowserCache: true
                    };
                    
                    console.log('开始分块加载模型:', mainPath);
                    
                    // 尝试使用流式加载模式
                    chunkLoader.load(
                        mainPath,
                        function(gltf) {
                            console.log('模型加载成功:', mainPath);
                            const model = gltf.scene;
                            loadedModels.push(model);
                            
                            // 优化模型处理 - 简化光照计算
                            model.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = false;
                                    child.receiveShadow = false;
                                    // 减少材质复杂度
                                    if (child.material) {
                                        child.material.envMapIntensity = 0.5;
                                    }
                                }
                            });
                            
                            // 让模型横向显示 - 旋转-90度（修正方向）
                            model.rotation.x = -Math.PI / 2; // 绕X轴旋转-90度
                            
                            // 优化模型 - 合并相同材质的几何体
                            optimizeModelGeometry(model);
                            
                            scene.add(model);
                            
                            // 调整相机
                            adjustCamera(model);
                            
                            // 添加渐进式加载更新
                            startProgressiveLoadingUpdate(model);
                            
                            // 隐藏加载动画
                            setTimeout(hideLoadingAnimation, 1000);
                        },
                        function(xhr) {
                            // 显示加载进度
                            if (xhr.lengthComputable && loadingText) {
                                const percent = Math.round((xhr.loaded / xhr.total) * 100);
                                loadingText.textContent = `正在加载模型: ${percent}% - 大型模型加载可能需要较长时间`;
                            }
                        },
                        function(error) {
                            console.error(`模型加载失败:`, error);
                            
                            // 特殊处理内存不足错误
                            if (error.message && (error.message.includes('out of memory') || error.message.includes('内存不足'))) {
                                showError('浏览器内存不足，正在尝试优化加载方式...');
                                // 尝试使用更低内存的加载方式
                                setTimeout(() => {
                                    tryLowMemoryLoading(mainPath);
                                }, 2000);
                                return;
                            }
                            
                            showError('模型加载失败，请确保模型文件格式正确且可用。');
                        }
                    );
                    
                } catch (error) {
                    console.error('分块加载初始化失败:', error);
                    showError('无法开始分块加载，请检查网络连接或文件权限。');
                }
            }
            
            // 低内存加载模式
            function tryLowMemoryLoading(modelPath) {
                console.log('尝试低内存加载模式');
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = '正在使用低内存模式加载...';
                }
                
                // 创建一个新的加载器，禁用一些高内存功能
                const lowMemoryLoader = new GLTFLoader(loadingManager);
                
                lowMemoryLoader.load(
                    modelPath,
                    function(gltf) {
                        console.log('低内存模式加载成功');
                        const model = gltf.scene;
                        
                        // 激进的内存优化
                        optimizeModelForLowMemory(model);
                        
                        scene.add(model);
                        adjustCamera(model);
                        hideLoadingAnimation();
                    },
                    undefined,
                    function(error) {
                        console.error('低内存模式加载失败:', error);
                        showError('无法加载模型，请尝试使用更小的模型文件或更强的设备。');
                    }
                );
            }
            
            // 开始加载
            startLoading();
        }
        
        // 优化模型几何体
        function optimizeModelGeometry(model) {
            // 这里可以实现几何体合并等优化
            // 对于非常大的模型，我们不进行合并以保持分块加载的优势
            console.log('模型几何体优化完成');
        }
        
        // 为低内存设备优化模型
        function optimizeModelForLowMemory(model) {
            model.traverse(function(child) {
                if (child.isMesh) {
                    // 简化几何体 - 如果有大量顶点
                    if (child.geometry && child.geometry.attributes.position.count > 10000) {
                        // 这里可以添加几何体简化逻辑
                        console.log('简化几何体顶点数');
                    }
                    
                    // 降低材质质量
                    if (child.material) {
                        child.material.roughness = 1; // 减少镜面反射计算
                        child.material.metalness = 0; // 减少金属效果计算
                        if (child.material.map) {
                            child.material.map.minFilter = THREE.LinearFilter; // 降低纹理过滤质量
                            child.material.map.magFilter = THREE.LinearFilter;
                        }
                    }
                }
            });
            console.log('低内存模式模型优化完成');
        }
        
        // 启动渐进式加载更新
        function startProgressiveLoadingUpdate(model) {
            // 在这里可以实现基于相机移动的动态加载/卸载模型块
            console.log('启动渐进式加载更新系统');
            
            // 添加定期检查相机位置的功能
            let lastCameraPosition = new THREE.Vector3();
            
            function checkCameraMovement() {
                if (!camera || !model) return;
                
                // 只有当相机移动超过阈值时才进行更新
                if (camera.position.distanceTo(lastCameraPosition) > 1.0) {
                    lastCameraPosition.copy(camera.position);
                    // 这里可以实现基于相机距离的LOD（细节级别）管理
                    updateModelLOD(model);
                }
                
                // 继续检查
                requestAnimationFrame(checkCameraMovement);
            }
            
            // 开始检查相机移动
            setTimeout(checkCameraMovement, 1000);
        }
        
        // 更新模型LOD（细节级别）
        function updateModelLOD(model) {
            // 简单的LOD实现 - 基于相机距离调整模型复杂度
            const distance = camera.position.distanceTo(model.position);
            
            // 根据距离调整模型质量
            if (distance > 50) {
                // 远距离 - 最低质量
                setModelQuality(model, 0.3);
            } else if (distance > 20) {
                // 中等距离 - 中等质量
                setModelQuality(model, 0.7);
            } else {
                // 近距离 - 高质量
                setModelQuality(model, 1.0);
            }
        }
        
        // 设置模型质量
        function setModelQuality(model, quality) {
            // 简单实现 - 启用/禁用某些细节部分
            // 在实际应用中，可以实现更复杂的LOD系统
            model.traverse(function(child) {
                if (child.isMesh && child.userData && child.userData.detailLevel) {
                    // 只显示质量级别高于当前设置的细节
                    child.visible = child.userData.detailLevel <= quality;
                }
            });
        }
        
        // 创建替代几何体
        function createFallbackGeometry() {
            console.log('创建替代几何体');
            
            // 创建一个简单的立方体
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true
            });
            
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            loadedModels.push(cube);
            
            // 调整相机
            adjustCamera(cube);
            
            // 隐藏加载动画
            setTimeout(() => {
                document.getElementById('loading-container').classList.add('hidden');
            }, 500);
        }
        
        // 调整相机以适合模型
        function adjustCamera(model) {
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;
            
            camera.position.set(center.x, center.y, cameraZ);
            controls.target.copy(center);
            controls.update();
        }
        
        // 扫描模型文件
        function scanModelFiles() {
            // 首先检查是否存在mx2文件夹中的分块模型文件
            // 注意：由于浏览器安全限制，我们不能直接扫描文件系统
            // 因此我们需要先尝试列出mx2文件夹中的模型块数量
            checkForChunksDirectory();
        }
        
        // 检查是否存在分块目录并尝试加载分块模型
        function checkForChunksDirectory() {
            // 我们尝试访问mx2目录中的第一个文件来验证目录存在
            const testChunkUrl = 'mx2/___0000005_0000000.glb';
            
            const xhr = new XMLHttpRequest();
            xhr.open('HEAD', testChunkUrl, true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        console.log('检测到mx2分块模型目录');
                        // 尝试加载预分块的模型
                        loadPreChunkedModel();
                    } else {
                        console.log('未检测到mx2分块模型目录，尝试加载单一模型文件');
                        modelFiles.push('merged.glb');
                    }
                }
            };
            xhr.onerror = function() {
                console.log('检测分块目录失败，尝试加载单一模型文件');
                modelFiles.push('merged.glb');
            };
            xhr.send();
        }
        
        // 加载预分块的模型
        function loadPreChunkedModel() {
            console.log('准备加载预分块的模型');
            // mx2目录中的模型块数量
            // 根据实际文件数量设置为29个块（索引0到28）
            totalChunksCount = 29;
            
            // 创建一个代表整个模型的空容器
            const fullModel = new THREE.Group();
            fullModel.name = 'FullModel';
            loadedModels.push(fullModel);
            scene.add(fullModel);
            
            // 启动分块加载过程
            startChunkLoading();
        }
        
        // 初始化分块加载
        function startChunkLoading() {
            console.log('开始分块加载过程');
            const loadingText = document.querySelector('.loading-text');
            
            if (loadingText) {
                loadingText.textContent = '准备加载分块模型...';
            }
            
            // 初始化分块加载器
            chunkLoader = initChunkLoader();
            
            // 构建块加载队列 - 按照块索引顺序加载
            for (let i = 0; i < totalChunksCount; i++) {
                const chunkIndex = String(i).padStart(7, '0');
                const chunkUrl = `mx2/___0000005_${chunkIndex}.glb`;
            
                // 添加到加载队列
                chunkLoadingQueue.push({
                    url: chunkUrl,
                    index: i,
                    priority: calculateChunkPriority(i) // 计算块的加载优先级
                });
            }
            
            // 按优先级排序加载队列
            chunkLoadingQueue.sort((a, b) => a.priority - b.priority);
            
            // 开始加载第一批块
            loadNextChunks();
        }
        
        // 计算块的加载优先级（简单实现）
        function calculateChunkPriority(chunkIndex) {
            // 中心区域的块优先加载
            // 假设中间索引（约20）是模型的中心部分
            const centerIndex = totalChunksCount / 2;
            const distanceFromCenter = Math.abs(chunkIndex - centerIndex);
            
            // 距离中心越近，优先级越高（数值越小）
            return distanceFromCenter;
        }
        
        // 加载单个分块
        function loadChunk(chunkInfo) {
            const { url, index, retries = 0 } = chunkInfo;
            const loadingText = document.querySelector('.loading-text');
            const loadingDetails = document.querySelector('.loading-details');
            
            // 标记此块为正在加载
            modelChunks[index] = {
                loading: true,
                loaded: false,
                object: null,
                retries: retries,
                startTime: Date.now()
            };
            
            const logMsg = `开始加载模型块 ${index}/${totalChunksCount}: ${url}${retries > 0 ? ` (重试 ${retries}/${maxRetries})` : ''}`;
            console.log(logMsg);
            addLoadingLog(logMsg);
            
            // 更新加载文本
            updateLoadingProgress();
            
            if (loadingDetails) {
                loadingDetails.textContent = `正在加载块 ${index}/${totalChunksCount}${retries > 0 ? ` (重试 ${retries}/${maxRetries})` : ''}`;
            }
            
            // 为了防止并发请求过多导致的问题，添加小延迟
            setTimeout(() => {
                // 创建带有缓存的加载函数
                function loadWithCache(url, onLoad, onProgress, onError) {
                    if (CACHE_ENABLED && resourceCache.has(url)) {
                        const cachedItem = resourceCache.get(url);
                        // 检查缓存是否过期
                        if (Date.now() - cachedItem.timestamp < CACHE_EXPIRE_TIME) {
                            addLoadingLog(`从缓存加载块 ${index}`);
                            onLoad(cachedItem.data);
                            return;
                        }
                    }
                    
                    try {
                        // 使用与initChunkLoader完全相同的加载器配置
                        const loader = initChunkLoader();
                        
                        // 使用fetch API获取文件，然后手动解析，以便更好地控制错误处理
                        fetch(url)
                            .then(response => {
                                // 检查响应头中的Content-Type
                                const contentType = response.headers.get('content-type');
                                if (contentType && contentType.includes('text/html')) {
                                    throw new Error(`服务器返回了HTML内容，而不是GLB文件。状态码: ${response.status}`);
                                }
                                
                                if (!response.ok) {
                                    throw new Error(`HTTP错误! 状态: ${response.status}`);
                                }
                                return response.arrayBuffer();
                            })
                            .then(buffer => {
                                // 验证文件是否包含glTF头或其他有效格式
                                const uint8Array = new Uint8Array(buffer.slice(0, 8));
                                const headerStr = String.fromCharCode.apply(null, uint8Array.slice(0, 4));
                                const header8Str = String.fromCharCode.apply(null, uint8Array);
                                
                                console.log(`模型块 ${index} 接收到的文件头: "${headerStr}"，完整8字节头: "${header8Str}"`);
                                
                                // 提取前30个字符以便调试
                                const preview = String.fromCharCode.apply(null, new Uint8Array(buffer.slice(0, 30)));
                                
                                // 检查是否是HTML内容（常见的HTML开头模式）
                                const isHTML = 
                                    header8Str.startsWith('<!DOCTYPE') || 
                                    header8Str.startsWith('<html') || 
                                    header8Str.startsWith('<!doctype') || 
                                    header8Str.startsWith('<HTML') || 
                                    header8Str.startsWith('<h') || 
                                    header8Str.startsWith('<?xml');
                                
                                // 特殊处理：如果检测到version字符串但文件应该是GLB
                                const hasVersionPrefix = headerStr.startsWith('vers');
                                
                                if (isHTML) {
                                    throw new Error(`检测到HTML内容，不是有效的GLB文件。前几个字符: "${preview}"。这很可能是Netlify服务器配置问题或URL大小写问题。`);
                                } else if (hasVersionPrefix) {
                                    console.warn(`警告: 模型块 ${index} 检测到version前缀，这可能是Git LFS指针文件或服务器配置问题。前几个字符: "${preview}"`);
                                    // 对于这种特殊情况，我们仍然尝试解析，但标记为可能的问题
                                    try {
                                        // 尝试使用loader解析文件
                                        loader.parse(
                                            buffer,
                                            '',
                                            function(gltf) {
                                                // 存入缓存
                                                if (CACHE_ENABLED) {
                                                    resourceCache.set(url, {
                                                        data: gltf,
                                                        timestamp: Date.now()
                                                    });
                                                }
                                                onLoad(gltf);
                                            },
                                            function(error) {
                                                // 如果解析失败，尝试使用备用URL
                                                console.error(`解析失败，尝试使用备用大小写URL`);
                                                // 尝试使用备用URL（改变大小写）
                                                const altUrl = url.includes('mx2/') ? url.replace('mx2/', 'MX2/') : url.replace('MX2/', 'mx2/');
                                                console.log(`尝试备用URL: ${altUrl}`);
                                                loadWithAltUrl(altUrl, loader, index, onLoad, onError);
                                            }
                                        );
                                        return; // 避免继续执行下面的代码
                                    } catch (e) {
                                        throw new Error(`处理version前缀文件时出错: ${e.message}。前几个字符: "${preview}"`);
                                    }
                                }
                                
                                // 如果是有效的glTF头，直接处理
                                if (headerStr === 'glTF') {
                                    console.log(`模型块 ${index} 检测到有效GLB文件头，开始解析`);
                                } else {
                                    // 对于非标准格式，记录日志但仍尝试解析
                                    console.warn(`警告: 模型块 ${index} 文件格式不标准，开头字符: "${headerStr}"，前30字符: "${preview}"，将尝试解析`);
                                }
                                
                                // 尝试使用loader解析文件
                                loader.parse(
                                    buffer,
                                    '',
                                    function(gltf) {
                                        // 存入缓存
                                        if (CACHE_ENABLED) {
                                            resourceCache.set(url, {
                                                data: gltf,
                                                timestamp: Date.now()
                                            });
                                        }
                                        onLoad(gltf);
                                    },
                                    function(error) {
                                        throw new Error(`解析错误: ${error.message}`);
                                    }
                                );
                            })
                            .catch(error => {
                                // 增强的错误处理，特别针对Netlify环境
                                let errorMessage = `加载失败: ${error.message}`;
                                
                                // 特殊处理常见错误
                                if (error.message.includes('Unexpected token')) {
                                    errorMessage = `加载失败: 服务器返回的内容不是有效的JSON或GLB格式。这很可能是服务器配置问题，导致返回了HTML页面而不是GLB文件。\n\n在Netlify环境中，请确保：\n1. 在_netlify.toml文件中正确配置了静态文件处理规则\n2. 没有错误的重定向规则影响到.glb文件请求\n3. 检查文件大小写是否与引用一致（Netlify是区分大小写的）`;
                                } else if (error.message.includes('404')) {
                                    errorMessage = `加载失败: 文件未找到。请检查文件路径是否正确。\n\n在Netlify环境中，请特别注意：\n1. 文件路径区分大小写\n2. 确保文件已正确部署到服务器\n3. 检查Netlify构建日志，确认文件是否被正确包含`;
                                } else if (error.message.includes('HTML')) {
                                    errorMessage = `加载失败: 检测到HTML内容，而不是GLB文件。这是典型的Netlify服务器配置问题。\n\n建议解决方案：\n1. 创建或修改_netlify.toml文件\n2. 添加正确的静态文件处理规则\n3. 确保重定向规则不会拦截.glb文件请求`;
                                } else if (error.message.includes('GLB') || error.message.includes('glTF')) {
                                    errorMessage = `加载失败: 文件不是有效的GLB格式。\n\n在Netlify环境中，这可能是因为：\n1. 服务器返回了HTML错误页面而非实际文件\n2. 静态文件MIME类型配置不正确\n3. 资源请求被重定向或拦截`;
                                }
                                
                                console.error(`模型块 ${index} 加载错误:`, error);
                                console.error(errorMessage);
                                onError(new Error(errorMessage));
                            });
                    } catch (e) {
                        console.error(`loadWithCache函数内部错误:`, e);
                        onError(new Error(`加载过程中发生内部错误: ${e.message}`));
                    }
                }
                
                // 备用URL加载函数，用于处理大小写问题
                function loadWithAltUrl(altUrl, loader, index, onLoad, onError) {
                    console.log(`开始使用备用URL加载模型块 ${index}: ${altUrl}`);
                    
                    // 使用XMLHttpRequest加载备用URL
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', altUrl, true);
                    xhr.responseType = 'arraybuffer';
                    
                    xhr.onload = function() {
                        if (xhr.status === 200) {
                            console.log(`备用URL加载成功，开始解析模型块 ${index}`);
                            const buffer = xhr.response;
                            
                            // 验证文件格式
                            const uint8Array = new Uint8Array(buffer.slice(0, 4));
                            const headerStr = String.fromCharCode.apply(null, uint8Array);
                            
                            if (headerStr !== 'glTF') {
                                console.warn(`警告: 备用URL加载的模型块 ${index} 文件格式不标准，开头字符: "${headerStr}"`);
                            }
                            
                            // 解析文件
                            loader.parse(
                                buffer,
                                '',
                                function(gltf) {
                                    console.log(`备用URL模型块 ${index} 解析成功`);
                                    onLoad(gltf);
                                },
                                function(error) {
                                    console.error(`备用URL模型块 ${index} 解析失败:`, error);
                                    onError(new Error(`备用URL解析失败: ${error.message}。请检查文件路径大小写或服务器配置。`));
                                }
                            );
                        } else {
                            console.error(`备用URL加载失败，状态码: ${xhr.status}`);
                            onError(new Error(`备用URL加载失败，状态码: ${xhr.status}。请检查文件路径大小写或服务器配置。`));
                        }
                    };
                    
                    xhr.onerror = function() {
                        console.error(`备用URL网络错误`);
                        onError(new Error(`备用URL网络错误。请检查文件路径大小写或服务器配置。`));
                    };
                    
                    xhr.send();
                }
                
                // 加载超时处理函数
                const timeoutId = setTimeout(() => {
                    const timeoutMsg = `模型块 ${index} 加载超时，将重试`;
                    console.error(timeoutMsg);
                    addLoadingLog(timeoutMsg, true);
                    
                    // 取消当前加载（尝试中止底层请求）
                    if (chunkLoader.manager && chunkLoader.manager.handlers) {
                        for (const handler of Object.values(chunkLoader.manager.handlers)) {
                            if (handler && handler.resourcePath === url) {
                                try {
                                    handler.abort();
                                } catch (e) {}
                            }
                        }
                    }
                    
                    // 如果重试次数未达到上限，则重试
                    if (retries < maxRetries) {
                        addLoadingLog(`将重试加载模型块 ${index}`);
                        // 添加到失败列表，稍后重试
                        failedChunks.push({
                            url: url,
                            index: index,
                            retries: retries + 1
                        });
                    } else {
                        addLoadingLog(`模型块 ${index} 达到最大重试次数，不再重试`, true);
                        // 标记此块为加载失败
                        modelChunks[index] = {
                            loading: false,
                            loaded: false,
                            error: new Error('加载超时')
                        };
                    }
                    
                    // 继续加载下一批块
                    loadNextChunks();
                }, 30000); // 30秒超时
                
                // 加载块
                loadWithCache(
                    url,
                    function(gltf) {
                        // 清除超时定时器
                        clearTimeout(timeoutId);
                        
                        const successMsg = `成功加载模型块 ${index}/${totalChunksCount}: ${url}`;
                        console.log(successMsg);
                        addLoadingLog(successMsg);
                        
                        const chunkModel = gltf.scene;
                        
                        // 优化块模型
                        optimizeChunkModel(chunkModel, index);
                        
                        // 存储加载的块
                        modelChunks[index] = {
                            loading: false,
                            loaded: true,
                            object: chunkModel
                        };
                        
                        // 将块添加到完整模型中
                        const fullModel = loadedModels.find(model => model.name === 'FullModel');
                        if (fullModel) {
                            fullModel.add(chunkModel);
                        }
                        
                        // 增加已加载块计数
                        loadedChunksCount++;
                        
                        // 更新加载进度
                        updateLoadingProgress();
                        
                        // 加载下一批块 - 即使当前块加载完成也继续加载
                        loadNextChunks();
                        
                    },
                    function(xhr) {
                        // 添加单个块的加载进度
                        if (xhr.lengthComputable) {
                            const percent = Math.round((xhr.loaded / xhr.total) * 100);
                            const currentChunkBytesLoaded = xhr.loaded;
                            const currentChunkBytesTotal = xhr.total;
                            
                            // 更新总字节数（如果是新块的首次加载）
                            if (!modelChunks[index].totalBytes) {
                                modelChunks[index].totalBytes = currentChunkBytesTotal;
                                totalBytesToLoad += currentChunkBytesTotal;
                            }
                            
                            // 计算当前已加载的总字节数
                            const previousLoadedBytes = modelChunks[index].loadedBytes || 0;
                            modelChunks[index].loadedBytes = currentChunkBytesLoaded;
                            
                            // 只在新数据到达时更新总字节计数
                            if (currentChunkBytesLoaded > previousLoadedBytes) {
                                totalBytesLoaded += (currentChunkBytesLoaded - previousLoadedBytes);
                            }
                            
                            // 更新详细进度信息
                            const speed = calculateLoadSpeed(totalBytesLoaded);
                            const remainingTime = calculateRemainingTime();
                            
                            if (loadingDetails) {
                                loadingDetails.textContent = `块 ${index} 加载中: ${percent}% | 速度: ${formatFileSize(speed)}/s | 预计剩余: ${remainingTime}`;
                            }
                        }
                    },
                    function(error) {
                        // 清除超时定时器
                        clearTimeout(timeoutId);
                        
                        const errorMsg = `加载模型块 ${index} 失败: ${error.message}`;
                        console.error(errorMsg);
                        addLoadingLog(errorMsg, true);
                        
                        // 如果重试次数未达到上限，则添加到失败列表以便重试
                        if (retries < maxRetries) {
                            const retryMsg = `将在延迟后重试加载模型块 ${index}`;
                            console.log(retryMsg);
                            addLoadingLog(retryMsg);
                            // 添加到失败列表，稍后重试
                            failedChunks.push({
                                url: url,
                                index: index,
                                retries: retries + 1
                            });
                        } else {
                            const maxRetryMsg = `模型块 ${index} 达到最大重试次数，不再重试`;
                            console.error(maxRetryMsg);
                            addLoadingLog(maxRetryMsg, true);
                            // 标记此块为加载失败
                            modelChunks[index] = {
                                loading: false,
                                loaded: false,
                                error: error
                            };
                        }
                        
                        // 继续加载下一批块
                        loadNextChunks();
                    }
                );
            }, 50); // 减少延迟，提高加载速度，不再使用 index * 100
        }

        // 加载下一批分块
        function loadNextChunks() {
            // 检查是否还有块需要加载
            if (chunkLoadingQueue.length === 0) {
                console.log('所有分块模型加载完成');
                onAllChunksLoaded();
                return;
            }

            // 计算当前正在加载的块数量
            const activeLoads = Object.values(modelChunks).filter(chunk => chunk.loading).length;

            // 如果当前加载的块数量少于最大并发数，则加载更多块
            const chunksToLoad = maxConcurrentChunkLoads - activeLoads;

            console.log(`当前正在加载: ${activeLoads} 个块, 队列中剩余: ${chunkLoadingQueue.length} 个块`);

            for (let i = 0; i < chunksToLoad && chunkLoadingQueue.length > 0; i++) {
                const nextChunk = chunkLoadingQueue.shift();
                loadChunk(nextChunk);
            }

            // 特殊处理：如果队列不为空但没有启动新的加载（可能是因为并发限制），
            // 则定期检查是否可以加载更多块
            if (chunkLoadingQueue.length > 0 && chunksToLoad <= 0) {
                setTimeout(() => {
                    // 再次检查是否有活跃的加载减少，以便加载更多块
                    const currentActiveLoads = Object.values(modelChunks).filter(chunk => chunk.loading).length;
                    if (currentActiveLoads < maxConcurrentChunkLoads) {
                        loadNextChunks();
                    }
                }, 500); // 500ms后再次检查
            }
        }

        // 更新加载进度显示
        function updateLoadingProgress() {
            const loadingText = document.querySelector('.loading-text');
            const progressBar = document.querySelector('.progress-bar');

            if (loadingText && totalChunksCount > 0) {
                // 计算块加载百分比
                const chunkPercent = Math.round((loadedChunksCount / totalChunksCount) * 100);

                // 计算文件大小加载百分比（如果有数据）
                let sizePercent = 0;
                if (totalBytesToLoad > 0) {
                    sizePercent = Math.round((totalBytesLoaded / totalBytesToLoad) * 100);
                }

                // 显示综合进度信息
                const speed = calculateLoadSpeed(totalBytesLoaded);
                const remainingTime = calculateRemainingTime();

                loadingText.textContent = `正在加载: ${loadedChunksCount}/${totalChunksCount} 块 (${chunkPercent}%)`;

                if (progressBar) {
                    // 使用文件大小百分比更准确地反映加载进度
                    const displayPercent = totalBytesToLoad > 0 ? sizePercent : chunkPercent;
                    progressBar.style.width = `${displayPercent}%`;

                    // 根据进度改变进度条颜色
                    if (displayPercent >= 90) {
                        progressBar.style.backgroundColor = '#4CAF50';
                    } else if (displayPercent >= 50) {
                        progressBar.style.backgroundColor = '#FFC107';
                    } else {
                        progressBar.style.backgroundColor = '#2196F3';
                    }
                }
            }
        }

        // 计算加载速度
        function calculateLoadSpeed(bytesLoaded) {
            const currentTime = Date.now();
            const elapsedTime = (currentTime - lastLoadedTime) / 1000; // 秒
            const speed = bytesLoaded / elapsedTime;
            return speed;
        }

        // 计算剩余时间
        function calculateRemainingTime() {
            const speed = calculateLoadSpeed(totalBytesLoaded);
            if (speed === 0) return '计算中...';
            
            const remainingBytes = totalBytesToLoad - totalBytesLoaded;
            const remainingSeconds = remainingBytes / speed;
            
            if (remainingSeconds < 60) {
                return `${Math.round(remainingSeconds)}秒`;
            } else if (remainingSeconds < 3600) {
                return `${Math.round(remainingSeconds / 60)}分钟`;
            } else {
                return `${Math.round(remainingSeconds / 3600)}小时`;
            }
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 优化单个模型块
        function optimizeChunkModel(chunkModel, chunkIndex) {
            // 对块模型进行优化处理
            chunkModel.traverse(function(child) {
                if (child.isMesh) {
                    // 禁用阴影计算以提高性能
                    child.castShadow = false;
                    child.receiveShadow = false;
                    
                    // 简化材质以降低内存使用
                    if (child.material) {
                        child.material.envMapIntensity = 0.5;
                        
                        // 对于低优先级或远距离的块，可以进一步降低质量
                        // 这里根据块索引进行简单的质量分级
                        if (chunkIndex % 5 === 0) { // 每隔5个块降低一些质量
                            child.material.needsUpdate = true;
                        }
                    }
                }
            });
            
            // 让模型横向显示 - 旋转-90度（修正方向）
            chunkModel.rotation.x = -Math.PI / 2; // 绕X轴旋转-90度
            
            console.log(`优化模型块 ${chunkIndex} 完成`);
        }
        
        // 所有分块加载完成后的处理
        function onAllChunksLoaded() {
            // 标记加载完成
            isLoadingComplete = true;
            
            // 检查是否有失败的块需要重试
            if (failedChunks.length > 0 && maxConcurrentChunkLoads > 0) {
                const retryMsg = `有 ${failedChunks.length} 个块加载失败，准备重试`;
                console.log(retryMsg);
                addLoadingLog(retryMsg);
                
                // 将失败的块重新添加到队列中
                chunkLoadingQueue = [...failedChunks, ...chunkLoadingQueue];
                failedChunks = [];
                
                // 继续加载
                loadNextChunks();
                return;
            }
            
            // 额外检查 - 如果队列中没有块但有正在加载的块，等待更多完成
            const activeLoads = Object.values(modelChunks).filter(chunk => chunk.loading).length;
            if (activeLoads > 0) {
                console.log(`等待最后 ${activeLoads} 个正在加载的块完成...`);
                setTimeout(onAllChunksLoaded, 1000); // 1秒后再次检查
                return;
            }
            
            // 强制完成检查：即使有一些块加载失败，也允许继续
            // 计算已加载时间
            const currentTime = Date.now();
            const elapsedTime = Math.round((currentTime - startTime) / 1000);
            
            // 获取成功加载的块数量
            const successfullyLoadedCount = Object.values(modelChunks).filter(chunk => chunk.loaded).length;
            const loadSummary = `成功加载 ${successfullyLoadedCount}/${totalChunksCount} 个模型块`;
            console.log(loadSummary);
            addLoadingLog(loadSummary);
            
            // 更新加载完成信息
            const loadingText = document.querySelector('.loading-text');
            const loadingDetails = document.querySelector('.loading-details');
            const progressBar = document.querySelector('.progress-bar');
            
            if (loadingText) {
                loadingText.textContent = '模型加载完成，正在准备场景...';
            }
            
            if (progressBar) {
                progressBar.style.width = '100%';
                progressBar.style.backgroundColor = '#4CAF50';
            }
            
            // 降低加载成功率的阈值，允许更多的块加载失败但仍能继续
            if (successfullyLoadedCount / totalChunksCount < 0.3) {
                console.log(`加载成功率过低: ${(successfullyLoadedCount / totalChunksCount * 100).toFixed(1)}%`);
                const errorMsg = '模型分块加载失败率过高';
                console.error(errorMsg);
                addLoadingLog(errorMsg, true);
                
                if (loadingText) {
                    loadingText.textContent = `模型加载失败率过高，仅成功加载 ${successfullyLoadedCount}/${totalChunksCount} 个块`;
                    loadingText.style.color = '#ff0000';
                }
                
                // 显示错误后隐藏加载动画
                setTimeout(() => {
                    const loadingContainer = document.getElementById('loading-container');
                    if (loadingContainer) {
                        loadingContainer.classList.add('hidden');
                    }
                    // 创建替代几何体
                    createFallbackGeometry();
                }, 3000);
                return;
            }
            
            // 获取完整模型
            const fullModel = loadedModels.find(model => model.name === 'FullModel');
            
            if (fullModel) {
                // 调整相机以适应完整模型
                adjustCamera(fullModel);
                
                // 启动渐进式加载更新
                startProgressiveLoadingUpdate(fullModel);
            }
            
            // 计算总加载时间
            const totalLoadTime = Math.round((Date.now() - startTime) / 1000);
            const timeMsg = `总加载时间: ${totalLoadTime}秒 | 平均速度: ${formatFileSize(totalBytesLoaded / totalLoadTime)}/s`;
            console.log(timeMsg);
            addLoadingLog(timeMsg);
            
            if (loadingDetails) {
                loadingDetails.textContent = `场景准备就绪，点击任意位置开始体验 | ${timeMsg}`;
            }
            
            // 确保完全加载后再隐藏加载动画
            setTimeout(() => {
                const loadingContainer = document.getElementById('loading-container');
                if (loadingContainer) {
                    loadingContainer.classList.add('hidden');
                }
            }, 2000);
        }
        
        // 添加加载日志
        function addLoadingLog(message, isError = false) {
            const logsElement = document.getElementById('loading-logs');
            if (!logsElement) return;
            
            const logItem = document.createElement('div');
            logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (isError) {
                logItem.style.color = '#ff6b6b';
            }
            logsElement.appendChild(logItem);
            logsElement.scrollTop = logsElement.scrollHeight;
        }
        
        // 显示/隐藏加载日志
        function setupLogsToggle() {
            const btn = document.getElementById('show-logs-btn');
            const logs = document.getElementById('loading-logs');
            
            if (btn && logs) {
                btn.addEventListener('click', () => {
                    logs.style.display = logs.style.display === 'none' || logs.style.display === '' ? 'block' : 'none';
                    btn.textContent = logs.style.display === 'block' ? '隐藏加载日志' : '显示加载日志';
                });
            }
        }
        
        // 设置缩放控制按钮
        function setupZoomControls() {
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            
            if (zoomInBtn && zoomOutBtn && controls) {
                // 放大按钮事件
                zoomInBtn.addEventListener('click', () => {
                    const zoomFactor = 1.2; // 放大因子
                    const newTargetDistance = camera.position.distanceTo(controls.target) / zoomFactor;
                    
                    // 计算新的相机位置（沿相机指向目标的方向移动）
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.add(direction.clone().multiplyScalar(-camera.position.distanceTo(controls.target) + newTargetDistance));
                    
                    // 更新相机的近平面和远平面
                    camera.updateProjectionMatrix();
                });
                
                // 缩小按钮事件
                zoomOutBtn.addEventListener('click', () => {
                    const zoomFactor = 1.2; // 缩小因子
                    const newTargetDistance = camera.position.distanceTo(controls.target) * zoomFactor;
                    
                    // 计算新的相机位置（沿相机指向目标的反方向移动）
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.add(direction.clone().multiplyScalar(-camera.position.distanceTo(controls.target) + newTargetDistance));
                    
                    // 更新相机的近平面和远平面
                    camera.updateProjectionMatrix();
                });
            }
        }
        
        // 初始化应用
        function initApp() {
            // 设置日志切换
            setupLogsToggle();
            
            // 改进的加载动画处理逻辑
            const loadingContainer = document.getElementById('loading-container');
            
            // 确保加载动画元素存在
            if (!loadingContainer) {
                console.error('未找到加载容器元素');
                return;
            }
            
            // 记录开始加载时间
            startTime = Date.now();
            lastLoadedTime = startTime;
            
            try {
                addLoadingLog('开始初始化应用');
                initThreeJS();
                scanModelFiles();
                
                // 设置缩放控制按钮
                setupZoomControls();
                
                // 设置加载提示5秒后平滑消失
                const loadingTip = document.getElementById('loading-tip');
                if (loadingTip) {
                    setTimeout(() => {
                        loadingTip.classList.add('hidden');
                    }, 5000);
                }
                
                // 注意：现在modelFiles可能为空，因为分块加载通过loadPreChunkedModel函数处理
                // 所以我们不再在这里加载模型，而是由checkForChunksDirectory和loadPreChunkedModel函数处理
                
            } catch (error) {
                const errorMsg = `应用初始化失败: ${error.message}`;
                console.error(errorMsg);
                addLoadingLog(errorMsg, true);
                
                // 发生错误时显示错误信息
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = '加载失败，请刷新页面重试';
                    loadingText.style.color = '#ff0000';
                }
                
                // 5秒后隐藏加载动画
                setTimeout(() => {
                    loadingContainer.classList.add('hidden');
                }, 5000);
            }
        }
        
        // 当页面加载完成后初始化应用
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
